(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{410:function(t,_,v){"use strict";v.r(_);var e=v(25),a=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"缓存概览"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存概览"}},[t._v("#")]),t._v(" 缓存概览")]),t._v(" "),v("p",[t._v("缓存分为三种:"),v("code",[t._v("浏览器缓存")]),t._v("，"),v("code",[t._v("服务器缓存")]),t._v("，"),v("code",[t._v("代理服务器缓存")]),t._v("。\n而在 HTTP 中具备缓存的是 "),v("code",[t._v("浏览器缓存")]),t._v("，接下来我们来详细讲讲"),v("code",[t._v("浏览器缓存")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"缓存的规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存的规则"}},[t._v("#")]),t._v(" 缓存的规则")]),t._v(" "),v("p",[t._v("我们认为浏览器具备一个"),v("code",[t._v("缓存数据库")]),t._v("，用于存储不经常变化的静态文件(js,css,图片等)。\n浏览器缓存分为"),v("code",[t._v("强制缓存")]),t._v("和"),v("code",[t._v("协商缓存")]),t._v("。")]),t._v(" "),v("ul",[v("li",[t._v("强制缓存\n当"),v("code",[t._v("HTTP")]),t._v("请求的资源直接在浏览器中的缓存数据库中就能找到，那么就直接从该数据库中获得。")]),t._v(" "),v("li",[t._v("协商缓存\n又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回 "),v("strong",[t._v("304")]),t._v("，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。")]),t._v(" "),v("li",[t._v("两者优先级\n两类缓存机制可以同时存在，"),v("strong",[t._v("强制缓存的优先级高于协商缓存")]),t._v("，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不再进行缓存协商。")])]),t._v(" "),v("h3",{attrs:{id:"缓存的方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存的方案"}},[t._v("#")]),t._v(" 缓存的方案")]),t._v(" "),v("h4",{attrs:{id:"强制缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),v("blockquote",[v("p",[t._v("只需"),v("code",[t._v("客户端")]),t._v("参与所涉及的 HTTP 头部字段，"),v("code",[t._v("Expires")]),t._v(" 和 "),v("code",[t._v("Cache-Control")]),t._v("， 后者的优先级先于前者。")])]),t._v(" "),v("h5",{attrs:{id:"expires"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),v("blockquote",[v("p",[t._v("Exprires 的值为"),v("strong",[t._v("服务端返回的数据到期时间")]),t._v("。")])]),t._v(" "),v("p",[t._v("当再次请求时的请求时间"),v("strong",[t._v("小于")]),t._v("返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能"),v("strong",[t._v("有误差")]),t._v("，这也将导致缓存命中的"),v("strong",[t._v("误差")]),t._v("(所以 Cache-Control 的优先级先于 Exprires)，另一方面，Expires 是 HTTP1.0 的产物，故现在大多数"),v("strong",[t._v("使用")]),t._v(" "),v("strong",[t._v("Cache-Control 替代")]),t._v("。")]),t._v(" "),v("h5",{attrs:{id:"cache-control"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache-Control")]),t._v(" "),v("blockquote",[v("p",[t._v("Cache-Control 有很多属性，不同的属性代表的意义也不同。")])]),t._v(" "),v("ul",[v("li",[t._v("private：客户端可以缓存")]),t._v(" "),v("li",[t._v("public：客户端和代理服务器都可以缓存")]),t._v(" "),v("li",[t._v("max-age=t：缓存内容将在 t 秒后失效")]),t._v(" "),v("li",[t._v("no-cache：需要使用协商缓存来验证缓存数据")]),t._v(" "),v("li",[t._v("no-store：所有内容都不会缓存")])]),t._v(" "),v("h4",{attrs:{id:"协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),v("blockquote",[v("p",[v("strong",[v("code",[t._v("客户端")]),t._v("和"),v("code",[t._v("服务器端")]),t._v("都需要参与。")])])]),t._v(" "),v("p",[t._v("协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回 "),v("strong",[t._v("304")]),t._v(" 状态码，浏览器拿到此状态码就可以直接使用缓存数据了。\n对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。")]),t._v(" "),v("h4",{attrs:{id:"last-modified"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[t._v("#")]),t._v(" Last-Modified")]),t._v(" "),v("p",[t._v("服务器在响应请求时，会告诉浏览器资源的最后修改时间。")]),t._v(" "),v("h5",{attrs:{id:"if-modified-since"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#if-modified-since"}},[t._v("#")]),t._v(" if-Modified-Since")]),t._v(" "),v("p",[t._v("浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。\n从字面上看，就是说：从某个时间节点算起，是否文件被修改了")]),t._v(" "),v("p",[t._v("如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK\n如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified")]),t._v(" "),v("h5",{attrs:{id:"if-unmodified-since"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#if-unmodified-since"}},[t._v("#")]),t._v(" if-Unmodified-Since")]),t._v(" "),v("p",[t._v("从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改")]),t._v(" "),v("p",[t._v("如果没有被修改:则开始`继续'传送文件: 服务器返回: 200 OK\n如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)")]),t._v(" "),v("p",[t._v("这两个的区别是一个是修改了才下载一个是没修改才下载。\nLast-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag。")]),t._v(" "),v("h4",{attrs:{id:"etag"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[t._v("#")]),t._v(" Etag")]),t._v(" "),v("p",[t._v("服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的"),v("strong",[t._v("唯一标识")]),t._v("（生成规则由服务器决定）")]),t._v(" "),v("h5",{attrs:{id:"if-none-match"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#if-none-match"}},[t._v("#")]),t._v(" If-None-Match")]),t._v(" "),v("p",[t._v("再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。")]),t._v(" "),v("p",[t._v("不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。\n相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304.")]),t._v(" "),v("p",[t._v("但是实际应用中由于 Etag 的计算是使用算法来得出的，"),v("strong",[t._v("而算法会占用服务端计算的资源")]),t._v("，所有服务端的资源都是宝贵的，所以就很"),v("strong",[t._v("少使用 Etag")]),t._v("了。")]),t._v(" "),v("h3",{attrs:{id:"缓存的优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存的优点"}},[t._v("#")]),t._v(" 缓存的优点")]),t._v(" "),v("p",[t._v("减少了冗余的数据传递，节省宽带流量\n减少了服务器的负担，大大提高了网站性能\n加快了客户端加载网页的速度 这也正是 HTTP 缓存属于客户端缓存的原因。")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6844903517702848526",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 缓存机制"),v("OutboundLink")],1),t._v(" "),v("a",{attrs:{href:"https://juejin.cn/post/6844903717574017031",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 缓存"),v("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=a.exports}}]);