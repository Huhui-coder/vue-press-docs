(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{444:function(t,v,_){"use strict";_.r(v);var a=_(25),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("通常的 web 优化方法，基本围绕在资源加载和 html渲染两个方面。前者针对首屏，后者针对可交互。资源优化上，我们总的方向是围绕更小的资源包上，比如常见的：压缩、减包、拆包、动态加载包及图片优化上。html 渲染上总的方向是更快的展示内容，比如通过 cdn 分发、dns 解析、http 缓存、数据预请求，数据缓存及首屏优化大杀器——直出等。")]),t._v(" "),_("h2",{attrs:{id:"压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#压缩"}},[t._v("#")]),t._v(" 压缩")]),t._v(" "),_("ul",[_("li",[t._v("对代码的压缩")]),t._v(" "),_("li",[t._v("对图片进行压缩")]),t._v(" "),_("li",[t._v("对最终生成的资源进行压缩")])]),t._v(" "),_("p",[t._v("压缩，主要是依靠"),_("code",[t._v("webpack")]),t._v("构建工具来实现。")]),t._v(" "),_("h2",{attrs:{id:"减包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减包"}},[t._v("#")]),t._v(" 减包")]),t._v(" "),_("ul",[_("li",[t._v("提取公共代码")])]),t._v(" "),_("h2",{attrs:{id:"拆包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#拆包"}},[t._v("#")]),t._v(" 拆包")]),t._v(" "),_("ul",[_("li",[t._v("将不同模块的代码分chunks， 打成不同的包")])]),t._v(" "),_("h2",{attrs:{id:"动态加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#动态加载"}},[t._v("#")]),t._v(" 动态加载")]),t._v(" "),_("ul",[_("li",[t._v("实现js代码的懒加载")]),t._v(" "),_("li",[t._v("实现图片的懒加载")])]),t._v(" "),_("h2",{attrs:{id:"图片优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图片优化"}},[t._v("#")]),t._v(" 图片优化")]),t._v(" "),_("ul",[_("li",[t._v("懒加载")])]),t._v(" "),_("h2",{attrs:{id:"cdn分发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cdn分发"}},[t._v("#")]),t._v(" cdn分发")]),t._v(" "),_("h2",{attrs:{id:"dns解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns解析"}},[t._v("#")]),t._v(" dns解析")]),t._v(" "),_("h2",{attrs:{id:"http缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[t._v("#")]),t._v(" http缓存")]),t._v(" "),_("h2",{attrs:{id:"数据预请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据预请求"}},[t._v("#")]),t._v(" 数据预请求")]),t._v(" "),_("h2",{attrs:{id:"数据缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据缓存"}},[t._v("#")]),t._v(" 数据缓存")]),t._v(" "),_("h2",{attrs:{id:"首屏优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#首屏优化"}},[t._v("#")]),t._v(" 首屏优化")]),t._v(" "),_("p",[t._v("从哪些方面来优化")]),t._v(" "),_("ol",[_("li",[t._v("页面中加载资源的数量（图片，字体，HTML和css）")])]),t._v(" "),_("p",[t._v("比如：减少页面中加载图片的数量，使用"),_("code",[t._v("svg")]),t._v("来替代图片，使用"),_("code",[t._v("base64")]),t._v(" 来替代图片的http请求，使用"),_("code",[t._v("雪碧图")]),t._v("来替代多个图片的加载方式。")]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("加载资源的大小")])]),t._v(" "),_("p",[t._v("使用"),_("code",[t._v("webpack")]),t._v(" 中的 "),_("code",[t._v("代码分片")]),t._v("，将一整块大的数据块，分割成一小块一小块的，每次加载时都只加载页面需要的那部分，实现按需加载。")]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("用户对网站的感知性能")])]),t._v(" "),_("p",[t._v("使用"),_("code",[t._v("SSR服务器端渲染")]),t._v("技术,减少白屏时间，缩短可操作时间。")]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("加载资源的策略")])]),t._v(" "),_("p",[_("code",[t._v("<script>")]),t._v("标签使用 "),_("code",[t._v("async")]),t._v(" 和 "),_("code",[t._v("defer")]),t._v(" 实现资源与DOM的异步加载。")]),t._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[t._v("启动资源的压缩")])]),t._v(" "),_("p",[t._v("启动"),_("code",[t._v("gzip")]),t._v("对HTML,css,js资源的压缩。")]),t._v(" "),_("h3",{attrs:{id:"浏览器如何渲染内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器如何渲染内容"}},[t._v("#")]),t._v(" 浏览器如何渲染内容")]),t._v(" "),_("p",[t._v("讲述从用户在地址栏输入url开始浏览器执行的一系列操作。")]),t._v(" "),_("ul",[_("li",[t._v("浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址 [DNS解析]")]),t._v(" "),_("li",[t._v("建立TCP连接 [三次握手]")]),t._v(" "),_("li",[t._v("浏览器发出读取文件(URL中域名后面部分对应的文件)的 HTPP请求,该请求报文作为TCP三次握手的第三个报文的数据发送给服务器。 [浏览器发送读取文件内容的HTTP请求到服务器]")]),t._v(" "),_("li",[t._v("服务器对浏览器请求作出响应,并把对应的HTML文本发送给浏览器。 [服务器发送HTML数据至浏览器]")]),t._v(" "),_("li",[t._v("浏览器开始渲染 HTML 内容 [浏览器渲染HTML]")]),t._v(" "),_("li",[t._v("释放 TCP 链接 [四次挥手]")])]),t._v(" "),_("p",[t._v("我们会测量浏览器收到响应内容的第一个字节的时间，称为首字节响应时间(Time To First Byte,TTFB)，这个数据可以很好的测量后端处理并返回内容的速度。")]),t._v(" "),_("h4",{attrs:{id:"请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#请求"}},[t._v("#")]),t._v(" 请求")]),t._v(" "),_("p",[t._v("每一个资源都会产生一个向服务器端发送的http请求，每次建立http 请求都是极为耗费时间的操作。")]),t._v(" "),_("h4",{attrs:{id:"连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[t._v("#")]),t._v(" 连接")]),t._v(" "),_("p",[t._v("如果是同一服务器的话，浏览器在建立一次连接之后，会保持该连接的打开状态以便于在其他的请求中复用该连接。浏览器可以在取回js文件后利用这个已建立的连接来获取一个字体文件，一个图片，只有当从不用服务器端获取资源时，浏览器才不得不重新建立连接来获取资源。")]),t._v(" "),_("p",[t._v("所以，尽量将静态资源放置到同一服务器上，让浏览器可以在建立http连接上尽可能的进行优化。")]),t._v(" "),_("h3",{attrs:{id:"页面大小"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#页面大小"}},[t._v("#")]),t._v(" 页面大小")]),t._v(" "),_("p",[t._v("页面大小同样对资源加载起到了至关重要的作用，我们可以将资源都进行"),_("code",[t._v("gzip")]),t._v("压缩。压缩之后，可以极大的减少文件的体积。")]),t._v(" "),_("h3",{attrs:{id:"感知性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#感知性能"}},[t._v("#")]),t._v(" 感知性能")]),t._v(" "),_("p",[t._v("网站加载的感知速度比实际的加载速度更重要。用户的感知速度主要是基于开始在页面上看见内容渲染的速度，页面变得可以交互的速度，以及网站滚动的流畅程度。")]),t._v(" "),_("h4",{attrs:{id:"关键路径渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关键路径渲染"}},[t._v("#")]),t._v(" 关键路径渲染")]),t._v(" "),_("p",[t._v("为了了解浏览器的关键路径渲染机制，首先要来了解浏览器是如何通过js,HTML,css来进行可视化渲染的。")]),t._v(" "),_("p",[t._v("浏览器首先会建立文档对象模型(Document Object Model,DOM)，浏览器会对服务器取回的HTML 进行解析，建立对应的DOM树。")]),t._v(" "),_("p",[t._v("在浏览器读取HTML时，可能会遇到 CSS样式表，浏览器会对服务器取回的CSS 进行解析，建立对应的CSS对象模型。\n再将 DOM树 和 CSS对象模型 结合起来，形成最终的 "),_("code",[t._v("渲染树")]),t._v("， "),_("code",[t._v("渲染树")]),t._v("上只会存在渲染页面所必须的元素(因此，"),_("code",[t._v("display: none")]),t._v("的元素不会在渲染树上)。")]),t._v(" "),_("p",[t._v("如果，浏览器遇到了"),_("code",[t._v("<script>")]),t._v("标签，依据标签上的属性，会进行不同的加载策略，如果是默认的标签行为，那么便会阻塞浏览器的渲染，会先将js资源加载完毕之后再去加载剩余的资源，(所以，我们一直推荐将"),_("code",[t._v("<script>")]),t._v(" 标签 放置到 "),_("code",[t._v("<body>")]),t._v("的最后,等到所有资源加载完了再去加载js)。\n如果是 "),_("code",[t._v("async")]),t._v(" 或者 "),_("code",[t._v("defer")]),t._v(" 属性，则会 与其他资源并行加载，是一个异步的过程，并不会阻塞浏览器的渲染。\n当然这两者之间还是会有不同的地方。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/6/27/16b96e86f8fcfb58?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"defer和async原理"}})]),t._v(" "),_("p",[t._v("所以相对于默认的script引用，这里配合defer和async就有两种新的用法，它们之间什么区别那？")]),t._v(" "),_("ol",[_("li",[t._v("默认引用 script:"),_("script",{attrs:{type:"text/javascript",src:"x.min.js"}})])]),t._v(" "),_("p",[t._v("当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。")]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("async模式 "),_("script",{attrs:{type:"text/javascript",src:"x.min.js",async:"async"}})])]),t._v(" "),_("p",[t._v("当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。并且是乱序执行的。")]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("defer模式 "),_("script",{attrs:{type:"text/javascript",src:"x.min.js",defer:"defer"}})])]),t._v(" "),_("p",[t._v("当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档解析完成，脚本才会执行。并且是按照书写"),_("code",[t._v("<script>")]),t._v("顺序执行的。")]),t._v(" "),_("blockquote",[_("p",[t._v("所以async和defer的最主要的区别就是async是异步下载并立即执行，然后文档继续解析，defer是异步加载后解析文档，然后再执行脚本，这样说起来是不是理解了一点了\n关于defer我们需要注意下面几点：")])]),t._v(" "),_("p",[t._v("defer只适用于外联脚本，如果script标签没有指定src属性，只是内联脚本，不要使用defer\n如果有多个声明了defer的脚本，则会按顺序下载和执行\ndefer脚本会在DOMContentLoaded和load事件之前执行")]),t._v(" "),_("p",[t._v("关于async，也需要注意以下几点：")]),t._v(" "),_("p",[t._v("只适用于外联脚本，这一点和defer一致\n如果有多个声明了async的脚本，其下载和执行也是异步的，不能确保彼此的先后顺序\nasync会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序")]),t._v(" "),_("p",[t._v("分别在什么样的场景下使用？")]),t._v(" "),_("ul",[_("li",[t._v("async")])]),t._v(" "),_("p",[t._v("使用 async 是下载完之后，就会立即执行，执行完之后，才会继续进行浏览器的渲染，如果，脚本是依赖DOM执行的话，这个时候就会报错(因为你的DOM可能还未加载完毕)。所以， async适合 不依赖 DOM 执行时。")]),t._v(" "),_("ul",[_("li",[t._v("defer")])]),t._v(" "),_("p",[t._v("使用 defer 是下载完之后，等到浏览器渲染完毕才会执行。所以，defer适合 依赖 DOM 执行时。")])])}),[],!1,null,null,null);v.default=s.exports}}]);