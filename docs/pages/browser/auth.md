
# 前端认证技术

## 概述

总所周知，`http` 本身是一种无状态的协议，那么 `http` 是如何进行用户身份认证并且记住用户的状态的?

举个栗子:用户登录之后，就不会再跳转至登录页了，而是跳转到正常的业务页面。

要想实现上述的场景需求，首先我们需要理解什么是 认证(Authentication)。

> 服务器端通过一系列手段(收集到用户的账号和密码等)进行用户身份认证，认证通过后让其无障碍的访问服务器端的资源。

常规认证流程如下：

当用户输入用户名，密码之后 ==> 发送到服务器端验证 ==> 验证通过 ==> 返回 Token(授权标识) ==> 前端存储 Token ==> 下次请求将其带上，即可实现认证流程。

关于前端存储这一块儿，可以借助前端的存储技术,比如: `localStorage`, `cookies`, `session`。

对于前端存储技术的介绍可以前往: [前端存储技术](https://huhui-coder.github.io/vue-press-docs/pages/browser/storage.html)

## 认证技术

接下来详细讲讲四种不同方式的认证手段。

1. HTTP Basic Authentication
2. session-cookie
3. Token 验证
4. OAuth(开放授权)

### HTTP Basic Authentication

这种授权方式是浏览器遵守 `http` 协议实现的基本授权方式, `http` 协议进行通信的过程中，`http` 协议定义了基本认证认证允许 `http` 服务器对客户端进行用户身份证的方法。

认证过程：

1． 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个`ajax`异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器:

```http
Get /index.html HTTP/1.0
Host:www.google.com
```

2． 服务器向客户端发送验证请求代码401,（WWW-Authenticate: Basic realm=”google.com”这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）服务器返回的数据大抵如下：

```http
HTTP/1.0 401 Unauthorised
Server: SokEvo/1.0
WWW-Authenticate: Basic realm=”google.com”
Content-Type: text/html
Content-Length: xxx
```

3． 当符合 `http1.0` 或 `1.1` 规范的客户端（如IE，FIREFOX）收到401返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。

4． 用户输入用户名和密码后，将用户名及密码以 `base64` 加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：

```http
Get /index.html HTTP/1.0
Host:www.google.com
Authorization: Basic d2FuZzp3YW5n
```

注：d2FuZzp3YW5n表示加密后的用户名及密码（用户名：密码 然后通过 `base64` 加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）

5． 服务器收到上述请求信息后，将 `Authorization` 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端。

效果：
客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于pending状态，这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带 `Authentication` 头的请求。

这个是出现较早的认证方式，实际使用中较少用到。仅做了解即可。

### session-cookie

`HTTP Cookie` 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。 `Cookie` 使基于无状态的 `HTTP协议` 记录稳定的状态信息成为了可能。

`Cookie` 主要用于以下三个方面：

1. 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
2. 个性化设置（如用户自定义设置、主题等）
3. 浏览器行为跟踪（如跟踪分析用户行为等）
4. 认证过程

服务器在接受客户端首次访问时在服务器端创建 `seesion` ，然后保存 `seesion` (我们可以将 `seesion` 保存在内存中，也可以保存在 `redis` 中，推荐使用后者)，然后给这个 `session` 生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。

签名。这一步只是对 `sid` 进行加密处理，服务端会根据这个 `secret` 密钥进行解密。（非必需步骤）

浏览器中收到请求响应的时候会解析响应头，然后将 `sid` 保存在本地 `cookie` 中，浏览器在下次 `http` 请求的请求头中会带上该域名下的 `cookie` 信息。

服务器在接受客户端请求时会去解析请求头 `cookie` 中的 `sid` ，然后根据这个 `sid` 去找服务器端保存的该客户端的 `session` ，然后判断该请求是否合法。

一旦用户登出，服务端和客户端同时销毁该会话在后续请求中，服务器会根据数据库验证会话 `id` ，如果验证通过，则继续处理；

#### 优缺点

优点:

1. 安全性高: 信息存储在服务器, 不易篡改。
2. 可以存储较大信息: Cookie 本身仅支持 4Kb 以下, 而 Session 存储于服务器, 依靠于数据库, 容量不限。
3. 存储类型多样: Cookie 只允许字符串类型, 而 Session 允许任意类型。
4. 可控性高: Cookie 本身只能设置固定有效时间, 而 Session 存储于服务器, 可以适应多种场景, 有效进行管理。
   1. 删除非法 Session
   2. 过期自动清理 Session
   3. 刷新有效时间

缺点:

1. 服务器存在负担: 随着用户量的增大, 每个用户都存储交互信息在服务器, 势必造成服务器负担。
2. Session 依靠 HTTPS 安全访问: 在不安全的网络环境下, Cookie 会被盗用, 意味着 SessionId 会被盗用
3. Sesion_ID 盗用风险: 正如上一点所说, 其实 session_ID 就是早期的 Token, 一旦被盗用就会导致非法用户盗用 Session。
4. 不可跨域: 这是由于 Cookie 不可跨域导致, 不同域名需要不同验证
5. 不可共享: 在多集群服务器的情况下, A服务器和B服务器 Session 不共享, 需要而外进行配置
6. CSRS攻击: 如果网站存在恶意脚本比如 <http://www.bank.com/api/transfer?count=1000&to=Tom>, 这种脚本存储在一段文本甚至是一张图片中, 如果我们使用 Session 的方式, 当我们点击图片就会导致触发。

### Token 验证

认证过程：

1. 用户输入登陆凭据；
2. 服务器验证凭据是否正确，然后返回一个经过签名的Token；
3. 客户端负责存储Token，可以存在localstorage，或者cookie中
4. 对服务器的请求带上这个Token；
5. 服务器对JWT进行解码，如果Token有效，则处理该请求；
6. 一旦用户登出，客户端销毁Token。

`cookie` 与 `taken` 看上去很像，那么他们到底有什么区别呢？

从标识的所携带的信息来看：
`sessionid` 他只是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的 `seesion` ，这里面才保存着用户的登陆状态。

但是 `Token` 本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个 `Token` 是否合法就行。

从使用方式来看：
`session-cookie` 是需要 `cookie` 配合的，居然要 `cookie` ，那么在 `http` 代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的 `cookie` ,然后每次请求再默认带上该域名下的 `cookie` 。但是我们知道 `http` 代理客户端不只有浏览器，还有原生APP等等，这个时候 `cookie` 是不起作用的，或者浏览器端是可以禁止`cookie` 的。

但是 `Token` 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的 `cookie` , `storage`，或者内存中，然后再下一次请求的请求头重带上这个 `Token` 就行了。(通常是放置到 `http` 请求头里的 `Authorization` 上)
简单点来说`cookie-session`机制他限制了客户端的类型，而`Token`验证机制丰富了客户端类型。

从时效性来看：
`session-cookie`的`sessionid`实在登陆的时候生成的而且在登出事时一直不变的，在一定程度上安全就会低，而`Token`是可以在一段时间内动态改变的。
可扩展性。`Token`验证本身是比较灵活的，一是`Token`的解决方案有许多，常用的是`JWT`，二来我们可以基于`Token`验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。

#### 优缺点

优点：

1. `Token` 可以防范, 或者说是专门防范 `CSRF` 攻击, 不会被自动加入请求头。
2. `Token` 存储在报文头的 `Authorization` 字段中。
3. `Token` 支持跨域, 可以与第三方共享, 具体原理后续会介绍。
4. `Token` 不依赖于 `Cookie` 在移动端中适配良好。
5. `Token` 存储在客户端(`localStorage`), 使服务器无状态化, 减少负担。

缺点:

1. `Token` 不能管理自己发出的令牌, 如果令牌被盗用, 服务端也难以进行注销。对此 `Session` 的优势就很明显, 可以很好的管控自己的会话。

### OAuth 2.0(开放授权)

OAuth 2.0是一个业界标准的授权协议，其定义了四种可以适用于各种应用场景的授权交互模式：授权码模式、应用授信模式、用户授信模式、简化模式。其中，授权码模式被广泛应用于第三方互联网开放平台，通过第三方登录是其最常见应用场景之一，比如使用微信、QQ和淘宝账号进行登录。

详见：<https://zhuanlan.zhihu.com/p/92051359>

## 实践

结合贾维斯项目来谈谈实际项目中是如何做项目鉴权的。

云客的前端架构是 FE ==> BFF ==> GO。

由于这种特殊的架构，通常是将鉴权放置到 BFF 项目中进行的。

任何一个 `FE` 的 `HTTP` 请求都会先走到 `BFF`(Koa 2) 的路由拦截器中，对于每一个请求，我们都需要从请求中的请求头拿到 `Authorization` 字段，然后将字段进行验证，判断是否有效(通过 `GO` 提供的接口进行验证)，如果有效，则放行。如果 `Token` 已经过期，用 `refresh_Token` 进行 `Token` 的续期，拿到新的 `Token` 再进行验证，验证通过放行，如果 `refresh_Token` 也无效，返回 `401` 状态码给 `FE` , `FE` 跳转到登录页。

结合图示说明如下：

![贾维斯认证流程](https://tva1.sinaimg.cn/large/e6c9d24egy1h2suf3hdyhj21010u0ab9.jpg)

此时，我们采用的方案是 `GO` 颁发 `Token` 认证信息(采用的是 JWT 授权方式)， `BFF` 进行权限的校验。

对于 在 `Koa2` 中自行实现, `session-coookie` 和 `Token` 验证方式的授权也很简单， `Koa2` 有对应的 中间件可直接使用，分别是: [Koa-session](https://www.npmjs.com/package/Koa-session) 和 [Koa-jwt](https://www.npmjs.com/package/Koa-jwt)