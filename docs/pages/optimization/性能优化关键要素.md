通常的 web 优化方法，基本围绕在资源加载和 html渲染两个方面。前者针对首屏，后者针对可交互。资源优化上，我们总的方向是围绕更小的资源包上，比如常见的：压缩、减包、拆包、动态加载包及图片优化上。html 渲染上总的方向是更快的展示内容，比如通过 cdn 分发、dns 解析、http 缓存、数据预请求，数据缓存及首屏优化大杀器——直出等。

## 压缩
- 对代码的压缩
- 对图片进行压缩
- 对最终生成的资源进行压缩
  
压缩，主要是依靠`webpack`构建工具来实现。


## 减包
- 提取公共代码

## 拆包
- 将不同模块的代码分chunks， 打成不同的包
## 动态加载
- 实现js代码的懒加载
- 实现图片的懒加载

## 图片优化
- 懒加载

## cdn分发

## dns解析

## http缓存

## 数据预请求

## 数据缓存

## 首屏优化

从哪些方面来优化
1. 页面中加载资源的数量（图片，字体，HTML和css）

比如：减少页面中加载图片的数量，使用`svg`来替代图片，使用`base64` 来替代图片的http请求，使用`雪碧图`来替代多个图片的加载方式。

2. 加载资源的大小

使用`webpack` 中的 `代码分片`，将一整块大的数据块，分割成一小块一小块的，每次加载时都只加载页面需要的那部分，实现按需加载。

3. 用户对网站的感知性能

使用`SSR服务器端渲染`技术,减少白屏时间，缩短可操作时间。

4. 加载资源的策略

`<script>`标签使用 `async` 和 `defer` 实现资源与DOM的异步加载。

5. 启动资源的压缩

启动`gzip`对HTML,css,js资源的压缩。

### 浏览器如何渲染内容

讲述从用户在地址栏输入url开始浏览器执行的一系列操作。
- 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址 [DNS解析]
- 建立TCP连接 [三次握手]
- 浏览器发出读取文件(URL中域名后面部分对应的文件)的 HTPP请求,该请求报文作为TCP三次握手的第三个报文的数据发送给服务器。 [浏览器发送读取文件内容的HTTP请求到服务器]
- 服务器对浏览器请求作出响应,并把对应的HTML文本发送给浏览器。 [服务器发送HTML数据至浏览器]
- 浏览器开始渲染 HTML 内容 [浏览器渲染HTML]
- 释放 TCP 链接 [四次挥手]

我们会测量浏览器收到响应内容的第一个字节的时间，称为首字节响应时间(Time To First Byte,TTFB)，这个数据可以很好的测量后端处理并返回内容的速度。

#### 请求
每一个资源都会产生一个向服务器端发送的http请求，每次建立http 请求都是极为耗费时间的操作。

#### 连接
如果是同一服务器的话，浏览器在建立一次连接之后，会保持该连接的打开状态以便于在其他的请求中复用该连接。浏览器可以在取回js文件后利用这个已建立的连接来获取一个字体文件，一个图片，只有当从不用服务器端获取资源时，浏览器才不得不重新建立连接来获取资源。

所以，尽量将静态资源放置到同一服务器上，让浏览器可以在建立http连接上尽可能的进行优化。

### 页面大小
页面大小同样对资源加载起到了至关重要的作用，我们可以将资源都进行`gzip`压缩。压缩之后，可以极大的减少文件的体积。


### 感知性能
网站加载的感知速度比实际的加载速度更重要。用户的感知速度主要是基于开始在页面上看见内容渲染的速度，页面变得可以交互的速度，以及网站滚动的流畅程度。

#### 关键路径渲染
为了了解浏览器的关键路径渲染机制，首先要来了解浏览器是如何通过js,HTML,css来进行可视化渲染的。

浏览器首先会建立文档对象模型(Document Object Model,DOM)，浏览器会对服务器取回的HTML 进行解析，建立对应的DOM树。

在浏览器读取HTML时，可能会遇到 CSS样式表，浏览器会对服务器取回的CSS 进行解析，建立对应的CSS对象模型。
再将 DOM树 和 CSS对象模型 结合起来，形成最终的 `渲染树`， `渲染树`上只会存在渲染页面所必须的元素(因此，`display: none`的元素不会在渲染树上)。

如果，浏览器遇到了`<script>`标签，依据标签上的属性，会进行不同的加载策略，如果是默认的标签行为，那么便会阻塞浏览器的渲染，会先将js资源加载完毕之后再去加载剩余的资源，(所以，我们一直推荐将`<script>` 标签 放置到 `<body>`的最后,等到所有资源加载完了再去加载js)。
如果是 `async` 或者 `defer` 属性，则会 与其他资源并行加载，是一个异步的过程，并不会阻塞浏览器的渲染。
当然这两者之间还是会有不同的地方。

![defer和async原理](https://user-gold-cdn.xitu.io/2019/6/27/16b96e86f8fcfb58?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

所以相对于默认的script引用，这里配合defer和async就有两种新的用法，它们之间什么区别那？

1. 默认引用 script:<script type="text/javascript" src="x.min.js"></script>

当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。

2. async模式 <script type="text/javascript" src="x.min.js" async="async"></script>

当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。并且是乱序执行的。

3. defer模式 <script type="text/javascript" src="x.min.js" defer="defer"></script>

当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档解析完成，脚本才会执行。并且是按照书写`<script>`顺序执行的。

>所以async和defer的最主要的区别就是async是异步下载并立即执行，然后文档继续解析，defer是异步加载后解析文档，然后再执行脚本，这样说起来是不是理解了一点了
关于defer我们需要注意下面几点：

defer只适用于外联脚本，如果script标签没有指定src属性，只是内联脚本，不要使用defer
如果有多个声明了defer的脚本，则会按顺序下载和执行
defer脚本会在DOMContentLoaded和load事件之前执行

关于async，也需要注意以下几点：

只适用于外联脚本，这一点和defer一致
如果有多个声明了async的脚本，其下载和执行也是异步的，不能确保彼此的先后顺序
async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序

分别在什么样的场景下使用？
- async

使用 async 是下载完之后，就会立即执行，执行完之后，才会继续进行浏览器的渲染，如果，脚本是依赖DOM执行的话，这个时候就会报错(因为你的DOM可能还未加载完毕)。所以， async适合 不依赖 DOM 执行时。

- defer

使用 defer 是下载完之后，等到浏览器渲染完毕才会执行。所以，defer适合 依赖 DOM 执行时。
